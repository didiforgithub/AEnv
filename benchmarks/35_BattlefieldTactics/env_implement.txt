Implementation Guide for Squad Reconnaissance and Elimination Environment

## Core Files Structure
- `squad_recon_env.py` - Main environment class inheriting from SkinEnv
- `tactical_observation.py` - Fog-of-war observation policy 
- `squad_world_generator.py` - Procedural world generation
- `combat_system.py` - Strength-based combat resolution

## Key Classes and Methods

### SquadReconEnv (squad_recon_env.py)
**transition(action)**: Process squad actions simultaneously. Handle movement by checking terrain validity (walls/forests block). For ATTACK_ENEMY_CAMP, calculate total strength of all squads adjacent to target camp. If total strength > camp strength, eliminate camp and award reward. If total strength <= camp strength, destroy all attacking squads. Update visibility map based on new squad positions.

**reward(action)**: Return 0.5 for first camp elimination, 0.5 for second camp. Track elimination count in globals.eliminated_camps. Return events list containing "enemy_camp_eliminated" when camps are destroyed.

**observe_semantic()**: Collect all active squad data (pos, strength, status). Merge 7x7 sensor views around each active squad to create tactical_map. Only include discovered enemy camps in observation. Calculate total_friendly_strength from active squads.

**render_skin(omega)**: Format tactical map as 15x15 ASCII grid. Show squad positions as S0/S1/S2, discovered enemy camps as E0/E1, walls as #, forests as T, open terrain as ., unexplored as ?. Include squad status table with ID, position, strength, and active status.

**done()**: Check three conditions: (1) eliminated_camps >= total_enemy_camps (victory), (2) t >= max_steps (timeout), (3) no active squads remaining (total elimination). When reading max_steps, if the loaded world has changed max_steps, it should override the environment's self.configs["termination"]["max_steps"].

### TacticalObservationPolicy (tactical_observation.py) 
**__call__(env_state, t)**: Extract active squad positions and merge their 7x7 sensor radii. Update visibility map with newly explored areas. Reveal enemy camps only when within sensor range. Return dict with squads, discovered_enemy_camps, tactical_map (15x15 boolean array of explored areas), and calculated total_friendly_strength.

### SquadWorldGenerator (squad_world_generator.py)
**_execute_pipeline(base_state, seed)**: 
1. **randomize_squad_strength**: Assign random strength 1-4 to each of 3 squads
2. **generate_terrain**: Place walls and forests avoiding spawn area (corners). Create partial barriers and chokepoints using wall_density 0.15, forest_density 0.1
3. **place_enemy_camps**: Randomly position 2 camps on valid terrain (not walls/forests), minimum 5 distance from spawn area. Assign random strength 2-6
4. **initialize_fog_of_war**: Mark only initial 7x7 areas around starting squad positions as explored

Use random seed throughout for reproducible generation. Validate all placements to ensure reachable paths exist.

### CombatSystem (combat_system.py)
**resolve_attack(attacking_squads, enemy_camp)**: Calculate sum of strength from all squads adjacent to target camp (using 4-directional adjacency). Compare total against camp defensive strength. Return combat result indicating success/failure and list of squads to remove if attack fails.

**get_adjacent_squads(camp_pos, all_squads)**: Return list of active squads positioned orthogonally adjacent to given camp coordinates.

## Critical Implementation Notes
- Fog-of-war updates every step based on active squad positions
- Combat requires coordination - single squad attacks usually fail
- Movement validation must check terrain type and grid boundaries  
- Enemy camps remain hidden until discovered by squad sensors
- Failed attacks destroy ALL participating squads, not just attacker
- Sensor radius is 3 tiles (7x7 grid centered on squad)
- Time limit creates pressure for efficient exploration and assault